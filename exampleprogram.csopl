; Clearly does not prevent evaluation of the second argument
; type: (→ bool (→ bool bool))
(define and (λ x bool
              (if x
                  (λ y bool y)
                  (λ y bool false))))
(define or (λ x bool
             (if x
                 (λ y bool true)
                 (λ y bool y))))
; type: (→ bool bool)
(define not (λ x bool
              (if x
                  false
                  true)))

; Type abstraction
; type: ∀ T * (→ (→ T bool) (→ T bool))
(define reverse
  (Λ T *
     (λ x (→ T bool)
       (λ y T
         (not (x y))))))
; Type application
; type: (→ (→ int bool) (→ int bool))
(define reverseinttobool
  [reverse int])

; type: (→ int bool)
(define lessorequalthanone (λ n int (iszero (pred n))))

; type: (→ int bool)
(define morethanone (reverseinttobool lessorequalthanone))

; Operator abstraction works fine
; Except when it doesn't... handle function is not enough
(define plusfive
  (λ n
    ((λ T (⇒ * *) (T int))
     (λ X * X))
    (succ (succ (succ (succ (succ n)))))))


(define applytwice
  (Λ T *
     (λ f (→ T T)
       (λ x T (f (f x))))))
; type: (→ (→ int int) (→ int int))
(define applyinttwice [applytwice int])
; (define applyfourtimes
; 	)

; type: bool
; eval: true
; ((and
;   (lessorequalthanone (succ 0)))
;  (morethanone (plusfive 0)))
